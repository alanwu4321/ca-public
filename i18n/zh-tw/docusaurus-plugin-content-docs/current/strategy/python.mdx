---
sidebar_position: 1
---

import { Highlight } from "../../../../../src/components/Highlight.js";

# Python ç­–ç•¥é–‹ç™¼

<Highlight color="#25c2a0"> Stable </Highlight>

## åŸºæœ¬çµæ§‹

- ä½¿ç”¨ `python 3` æ’°å¯« `Strategy` Class
- ç³»çµ±é€éå›ºå®šä»‹é¢å‘¼å«ï¼Œå‚³å…¥å¸‚å ´è³‡æ–™ï¼Œç­–ç•¥é ˆå›å‚³æ˜¯å¦åŸ·è¡Œè¨‚å–®
- ç­–ç•¥é ˆè‡ªè¡Œç¶­è­·è¨‚å–®ç”Ÿå‘½é€±æœŸ
- å¯ä»¥ä½¿ç”¨ [TA-LIB](https://github.com/acrazing/talib-binding-node) è¨ˆç®—å¸¸è¦‹æŠ€è¡“æŒ‡æ¨™ï¼Œä½¿ç”¨ TA å­˜å–
- å¯ä»¥ä½¿ç”¨ `CA.log(str)` ç´€éŒ„é‹è¡Œè³‡è¨Š

## ç­–ç•¥

```python
# Class name must be Strategy
class Strategy():
    # option setting needed
    def __setitem__(self, key, value):
        self.options[key] = value

    # option setting needed
    def __getitem__(self, key):
        return self.options.get(key, '')

    def __init__(self):
        # strategy property needed
        self.subscribed_books = {
            'Bitfinex': {
                'pairs': ['ETH-USDT'],
            },
        }

        # seconds for broker to call trade()
        # do not set the frequency below 60 sec.
        # 10 * 60 for 10 mins
        self.period = 10 * 60
        self.options = {}

        # user defined class attribute
        self.last_type = 'sell'


    # called every self.period
    def trade(self, information):
        # for single pair strategy, user can choose which exchange/pair to use when launch, get current exchange/pair from information
        exchange = list(information['candles'])[0]
        pair = list(information['candles'][exchange])[0]
        if self.last_type == 'sell':
            self.last_type = 'buy'
            return [
                {
                    'exchange': exchange,
                    'amount': 1,
                    'price': -1,
                    'type': 'MARKET',
                    'pair': pair,
                },
            ]
        else:
            self.last_type = 'sell'
            return [
                {
                    'exchange': exchange,
                    'amount': -1,
                    'price': -1,
                    'type': 'MARKET',
                    'pair': pair,
                },
            ]
        return []


    def on_order_state_change(self, order):
        CA.log("on order state change message: " + str(order) + " order price: " + str(order["price"]))

```

## æ¶æ§‹

### Candles K ç·šè³‡è¨Š

ç³»çµ±å‘¼å« `strategy` æ™‚ï¼Œæœƒå‚³å…¥ `information` ç‰©ä»¶ï¼Œä»¥æä¾› 3 å¤§é¡è³‡è¨Šï¼š `candles` (K ç·šè³‡è¨Š), `orders` (è¨‚å–®ï¼‰ï¼Œä»¥åŠ ` orderBooks` (é™åƒ¹è¨‚å–®ç°¿)ï¼å–ç”¨æ–¹æ³•ç‚º:

```python
information['candles']
information['orders']
information['orderBooks']
```

:::note
Candle æœƒä»¥ array of object çš„å½¢å¼å‚³å…¥ä¸Šæ¬¡å‘¼å«åˆ°æ­¤æ¬¡å‘¼å«çš„ K ç·šåœ–è³‡è¨Šï¼Œå…±å«æœ‰ 6 é …è³‡è¨Š openã€closeã€highã€lowã€volume å’Œ timeï¼Œå–ç”¨æ–¹å¼å¦‚ä¸‹:
:::

```python
information['candles'][exchange][pair][0]['open']
information['candles'][exchange][pair][0]['close']
information['candles'][exchange][pair][0]['high']
information['candles'][exchange][pair][0]['low']
information['candles'][exchange][pair][0]['volume']
information['candles'][exchange][pair][0]['time']
```

### Exchange äº¤æ˜“æ‰€

ç­–ç•¥ä½¿ç”¨è€…å¯æ–¼ä½¿ç”¨ç­–ç•¥æ™‚æ±ºå®šä½¿ç”¨çš„ exchange äº¤æ˜“æ‰€ (ä¾‹å¦‚ Bitfinex), é€™æ™‚æ­¤è¨­å®šæœƒè¢«å¿½ç•¥ï¼Œä»¥ä½¿ç”¨è€…åŸ·è¡Œç­–ç•¥æ™‚é¸æ“‡ç‚ºä¸»ï¼Œç¨‹å¼å…§è«‹ä½¿ç”¨ information å–å¾—ç•¶å‰ä½¿ç”¨çš„ exchange é€²è¡Œäº¤æ˜“

```python
exchange = list(information['candles'])[0]
```

### Pair äº¤æ˜“å°

Crypto-Arsenal æ”¯æ´å–®ä¸€ Strategy åŒæ™‚è¨»å†Šå¤šçµ„äº¤æ˜“ `pair`ï¼Œå› æ­¤ `candle`, `orders`èˆ‡ `orderBooks` æœƒåŒæ™‚å‚³å…¥å¤šçµ„ pair çš„è³‡è¨Šã€‚ç­–ç•¥ä½¿ç”¨è€…å¯æ–¼ä½¿ç”¨ç­–ç•¥æ™‚æŒ‡å®šä½¿ç”¨çš„ `pair` (ä¾‹å¦‚ BTC-USDT)ï¼Œé€™æ™‚ç¨‹å¼å…§è¨­å®šçš„ `pair` æœƒä½¿ç”¨åŸ·è¡Œç­–ç•¥æ™‚æŒ‡å®šçš„äº¤æ˜“å°ã€‚ç­–ç•¥å…§å¯ä½¿ç”¨ `information` å–å¾—ç•¶å‰ä½¿ç”¨çš„ `pair` é€²è¡Œäº¤æ˜“

```python
pair = list(information['candles'][exchange])[0]
```

### Assets è³‡ç”¢

ç­–ç•¥æ“æœ‰éš¨æ™‚æ›´æ–°çš„ `assets` è³‡ç”¢è³‡è¨Šï¼Œå³ç•¶å‰å¯é€²è¡Œæ“ä½œçš„è²¨å¹£ï¼Œå–ç”¨æ–¹å¼å¦‚ä¸‹:

```python
  pair = list(information['candles'][exchange])[0] #BTC-USDT
  target_currency = pair.split('-')[0]  #BTC
  base_currency = pair.split('-')[1]  #USDT
  # å–å¾—ç•¶ä¸‹æ“æœ‰çš„è²¨å¹£æ•¸é‡
  base_currency_amount = self['assets'][exchange][base_currency]
  target_currency_amount = self['assets'][exchange][target_currency]
```

### Orders è¨‚å–®

ä½¿ç”¨ `information['orders']` å–å¾—è¨‚å–®è³‡è¨Šï¼Œä»¥ list of dirctionary çš„å½¢å¼å„²å­˜ï¼Œç¬¬ä¸€ç­†è¨‚å–®ç‚º `information['orders'][0]`ï¼Œè¨‚å–®å…§åŒ…å«çš„è³‡æ–™æœ‰ï¼š `price`, `amount`, `status` å’Œ`orderId`ï¼Œå…¶ä¸­ status å¯èƒ½ç‚º`FILLED` æˆ– `NEW`ï¼Œåˆ†åˆ¥ä»£è¡¨æˆäº¤æˆ–å°šæœªæˆäº¤ã€‚å–ç”¨ç¯„ä¾‹å¦‚ä¸‹:

```python
  for i in range(len(information['orders'])):
    Log('order price: ' + str(information['orders'][i]['price']) +
    ' ,order amount: ' + str(information['orders'][i]['amount']) +
    ' ,status: ' + str(information['orders'][i]['status']) +
    ' ,orderId: ' + str(information['orders'][i]['orderId']))

```

### Order Books é™åƒ¹è¨‚å–®ç°¿

Order Books æ˜¯åœ¨å¯¦éš›äº¤æ˜“æ™‚æ‰æœƒä½¿ç”¨ï¼Œä»¥è§€å¯Ÿç•¶ä¸‹å¸‚å ´é™åƒ¹å–®çš„åƒ¹æ ¼èˆ‡æ•¸é‡ï¼Œåœ¨å›æ¸¬å’Œç«¶æŠ€å ´æ¯”è³½éƒ½ä¸æœƒç”¨åˆ°ã€‚(åœ¨åŸ·è¡Œ Backtest æ¨¡å¼ä¸­ï¼Œä¸æœƒå‚³å…¥ Order Books è³‡è¨Šã€‚)
ä½¿ç”¨ Order Books å¯å–å¾—æŒ‡å®šäº¤æ˜“æ‰€ä¸­æŒ‡å®šäº¤æ˜“å°çš„è¨‚å–®ç°¿è³‡è¨Šï¼Œåˆ†ç‚º `asks` è²·åƒ¹èˆ‡ `bids` è³£åƒ¹å…©å¤§é¡ï¼Œå¯å–å¾—ç•¶ä¸‹è¨‚å–®ç°¿çš„ `price` åƒ¹æ ¼, `count` è¨‚å–®æ•¸é‡å’Œ `amount` å¹£æ•¸é‡ï¼Œå–ç”¨æ–¹å¼å¦‚ä¸‹:

```python
  order_books = information['orderBooks']
  one_order_book = order_books[exchange][pair]

  ask_order_book = one_order_book['asks']
  last_ask_price = ask_order_book[-1]['price']
  last_ask_count = ask_order_book[-1]['count']
  last_ask_amount = ask_order_book[-1]['amount']

  bid_order_book = one_order_book['bids']
  last_bid_price = bid_order_book[-1]['price']
  last_bid_count = bid_order_book[-1]['count']
  last_bid_amount = bid_order_book[-1]['amount']

```

## CA Strategy ç•Œé¢

:::caution

`Strategy` class ç­–ç•¥å¿…é ˆæœ‰ä»¥ä¸‹ methods

:::

### `trade`

åœ¨ Crypto-Arsenal çš„ç­–ç•¥ä¸­ï¼Œè¦å‘äº¤æ˜“æ‰€ä¸‹è¨‚å–®çš„æ–¹å¼æ¡ç”¨ç³»çµ±å‘¼å«`trade`çš„å›å‚³å€¼é€²è¡Œäº¤æ˜“ã€‚

```python
def trade(self, information):
    [
        {
        'exchange': string
        'pair': string
        'type': string
        'amount': float
        'price': float
        }
    ]
```

#### æ¬„ä½èªªæ˜

- exchange: æ­¤ç­†è¨‚å–®è¦å‘å“ªå€‹äº¤æ˜“æ‰€é€²è¡Œäº¤æ˜“
- pair: äº¤æ˜“è²¨å¹£å°
- type: æ­¤ç­†è¨‚å–®æ¡ç”¨ä½•ç¨®äº¤æ˜“æ–¹å¼ (é™åƒ¹: `LIMIT` å¸‚åƒ¹: `MARKET`)
- amount: è¦äº¤æ˜“çš„æ•¸ä½è²¨å¹£æ•¸é‡ï¼Œå¤§æ–¼ 0 ä»£è¡¨è³¼è²·ï¼Œå°æ–¼ 0 ä»£è¡¨è²©è³£
- price: ä»¥å¤šå°‘åƒ¹æ ¼é€²è¡Œäº¤æ˜“ï¼Œè‹¥æ¡ç”¨å¸‚åƒ¹ï¼Œæ­¤æ¬„ä½å¯ä»»æ„å¡«å€¼

#### é™åƒ¹ç¯„ä¾‹

æ­¤è¨‚å–®ç‚ºæ¬²å‘`Binance`äº¤æ˜“æ‰€ï¼Œä»¥æ¯å–®ä½`212.42`è³¼è²·`1`å€‹`ETH-USDT`çš„äº¤æ˜“é…å°

```python
[
  {
    'exchange': 'Binance',
    'pair': 'ETH-USDT',
    'type': 'LIMIT',
    'amount': 1,
    'price': 212.42
  }
]
```

#### å¸‚åƒ¹ç¯„ä¾‹

æ­¤è¨‚å–®ç‚ºæ¬²å‘`Binance`äº¤æ˜“æ‰€ï¼Œä»¥`å¸‚åƒ¹`è³¼è²·`1`å€‹`ETH-USDT`çš„äº¤æ˜“é…å°

**é›–ç„¶äº¤æ˜“æ¡ç”¨å¸‚åƒ¹ï¼Œprice ä»é ˆå­˜åœ¨ï¼Œå€¼ç‚ºéš¨æ„æ•¸å€¼**

```python
[
  {
    'exchange': 'Binance',
    'pair': 'ETH-USDT',
    'type': 'MARKET',
    'amount': 1,
    'price': -1
  }
]
```

### `on_order_state_change`

å›å‚³æ¯ä¸€ç­†è¨‚å–®ç´€éŒ„ï¼Œçµæ§‹å¦‚ä¸‹

```python
{
    'exchange': 'Bitfinex',
    'pair': 'ETH-USDT',
    'amount': 1.0,
    'amountFilled': 1.0,
    'price': 1849.7,
    'type': 'MARKET',
    'status': 'FILLED'
}
```

#### ç¯„ä¾‹

ç­–ç•¥å…§éœ€ `define` ä¸€å€‹å‡½æ•¸ `on_order_state_change`ï¼Œå¹³å°æœƒä¾ç…§ä½¿ç”¨è€…å®šç¾©ä¹‹é€±æœŸå‘¼å«æ­¤å‡½æ•¸ï¼Œä»¥å–å›è¨‚å–®è³‡è¨Šä¸¦å°å‡ºç›¸é—œè³‡è¨Šã€‚

```python
def on_order_state_change(self,  order):
    CA.log("on order state change message: " + str(order) + " order price: " + str(order["price"]))
```

## CA ç­–ç•¥æ¨¡çµ„

### `CA.log`

ç”¨ä¾†å°å‡ºæŒ‡å®šè¨Šæ¯ï¼Œå¯å°æœ€å¤§é•·åº¦ç‚º 200 å€‹å­—ä¸²

```python
CA.log(str);
```

#### ç¯„ä¾‹

å°å‡ºæ”¶ç›¤åƒ¹ã€é–‹ç›¤åƒ¹èˆ‡äº¤æ˜“é‡

```python
exchange = list(information['candles'])[0] //Bitfinex
pair = list(information['candles'][exchange])[0] //BTC-USDT
CA.log(information['candles'][exchange][pair][0]['close'])
CA.log(information['candles'][exchange][pair][0]['open'])
CA.log(information['candles'][exchange][pair][0]['volume'])
```

#### ç¯„ä¾‹

å°å‡ºæ“æœ‰çš„è³‡ç”¢'USDT'å’Œ'BTC'

```python
CA.log('assest usdt: ' + str(self['assets'][exchange]['USDT']))
CA.log('assest btc: ' + str(self['assets'][exchange]['BTC']))
```

### `CA.get_last_order_snapshot`

å›å‚³æœ€å¾Œä¸€æ¬¡æˆäº¤çš„è¨‚å–®è³‡è¨Šï¼Œä½¿ç”¨ `dictionary` ç´€éŒ„æˆäº¤è¨‚å–®è³‡è¨Š

```python
  exchange: string;
  pair: string;
  orderId: number;
  amount: number;
  amountFilled: number;
  price: number;
  type: string;
  status: string;
  margin: boolean;
```

#### ç¯„ä¾‹

å–å›æœ€å¾Œä¸€æ¬¡æˆäº¤ç´€éŒ„ï¼Œä¸¦å°å‡ºåƒ¹é‡è³‡è¨Šã€‚èˆ‡ `on_order_state_change` ä¸åŒï¼Œ`CA.get_last_order_snapshot` å‡½æ•¸æ˜¯åœ¨ `trade` å‡½æ•¸ç•¶ä¸­å‘¼å«ã€‚

```python
snap = CA.get_last_order_snapshot()
if snap != {}:
    CA.log( 'snap_amount: ' + str(snap['amount']) + ' ,snap_price: ' + str(snap['price']))

```

### `CA.cancel_order`

åˆªé™¤è¨‚å–®å¯ä½¿ç”¨ `CA.cancel_order`

```
  exchange: string;
  pair: string;
  orderId: number
```

#### ç¯„ä¾‹

ä»¥ä¸‹ç¯„ä¾‹ç‚ºåˆªé™¤ç¬¬ä¸€ç­†æ›ä¸Šçš„è¨‚å–®:

```python
  CA.cancel_order({
    exchange: 'binance',
    pair: 'BTC-USDT',
    orderId: information['orders'][0]
  })
```

### `CA.query_history_data`

å¯åœ¨ `__init__` å‡½æ•¸ä¸­å–å¾—éå»ä¸€æ®µæ™‚é–“çš„æ­·å²è³‡æ–™ï¼Œä»¥ä¾¿åŸ·è¡Œç­–ç•¥ç•¶ä¸‹å³å¯è¨ˆç®—ç›¸é—œåƒæ•¸ï¼ˆä¾‹å¦‚ MAï¼‰ã€‚
CA.query_history_data(length, period) å¯å–å¾—éå»å¹¾å€‹ `length` é€±æœŸ `period` çš„è³‡æ–™ã€‚

**Input**

```
  length: number;
  period: number;
```

**Output**

```
  error: string;
  candles: JSON;
```

#### ç¯„ä¾‹

```python
def __init__(self):

    self.subscribed_books = {
        'Binance': {
            'pairs': ['BTC-USDT'],
        },
    }
    self.period = 60 * 60  # 1 hour

    # query the past 7 days data
    self.history_data = CA.query_history_data(168, self.period)

    if self.history_data:
        exchange = list(self.history_data['candles'])[0]
        pair = list(self.history_data['candles'][exchange])[0]
        high_list = np.array([])
        for candles in self.history_data['candles'][exchange][pair]:
            CA.log('history high: ' + str(candles['high']))

```

### `CA.storage`

<Highlight color="#ffba00"> In Progress </Highlight>

å­˜å–éµå€¼å° å¯åœ¨ç­–ç•¥çµæŸå¾Œè®€å–

**Input**

To set key value

```
  key: string;
  value: any;
```

To access key

```
  key: string;
```

**Output**

```
  value: string;
```

#### ç¯„ä¾‹

```python
CA.storage('string', 'to the moon ğŸŒ™')
val = CA.storage('string') # to the moon ğŸŒ™

CA.storage('int', 131441)
val = CA.storage('int') # 131441

CA.storage('none', None)
val = CA.storage('none') # None
```

## é€²éšæ¨¡çµ„

### `np`

å¯ä½¿ç”¨ np å­˜å– [numpy](http://www.numpy.org/)

### `talib`

å¯ä½¿ç”¨ talib å­˜å– [talib](https://github.com/mrjbq7/ta-lib)

#### ç¯„ä¾‹

ä½¿ç”¨ np.appendï¼Œä½¿ç”¨ talib è¨ˆç®— RSI

```python
self.close_price_trace = np.append(self.close_price_trace, [float( information['candles'][exchange][pair][0]['close'])])
rsi = talib.RSI(self.close_price_trace, Len)[-1]
```

## å­˜å–ç­–ç•¥åƒæ•¸

:::info
ç³»çµ±é ç•™åƒæ•¸
:::

### ç©ºå–®äº¤æ˜“ `is_shorting`

ä½¿ç”¨è€…é€éå°‡ `is_shorting` åƒæ•¸è¨­å®šç‚º trueï¼Œå¯é–‹å•Ÿç©ºå–®äº¤æ˜“æ¨¡å¼

### æ‰‹çºŒè²» `exchange_fee`

å¦å¯èª¿æ•´ `exchange_fee` ä»¥åŠ `spread`ï¼Œä»¥è¨­å®šæ›´åš´æ ¼çš„å›æ¸¬æ¢ä»¶

![image2](https://drive.google.com/uc?export=view&id=1IWJoekgYPgQWfxfLv_DZ3KjtTkuIeA4L)

ä¸Šåœ–æ‰€ç¤ºï¼Œ`exchange_fee` è¨­å®šç‚º `0.01`ï¼Œä»£è¡¨æ¯ä¸€ç­†äº¤æ˜“æœƒåŠ æ”¶ç¸½é¡ **1%** è²»ç”¨

:::note
è‹¥æ²’æœ‰è¨­å®šï¼Œé è¨­æ˜¯ **0.1%** çš„æ‰‹çºŒè²»
:::

### æ»‘åƒ¹èª¿æ•´ `spread`

`spread` ä»£è¡¨æ»‘é»ï¼Œ`0.05` ä»£è¡¨æ¯ç­†äº¤æ˜“åƒ¹æ ¼æœƒæœ‰ **5%** å·®ç•°

### è‡ªå®šç¾©åƒæ•¸

é€é `self['OPTION_NAME']` å­˜å–ç­–ç•¥åƒæ•¸

You can add some extra arguments for the strategy and change these arguments for every live trade, backtest or simulation.
For example, if you have the following configuration for a strategy

:::caution
All arguments are actually stored and parsed as `String` type in your strategy code. **So you have to parse it by your self!**
:::

#### Type

- Boolean

  A **STRING** that indicates either `true` or `false`

- Number

  A **STRING** that represents a `float` value.

- String

  A **STRING** that holds a `ASCII` string

- Select

  A **STRING** that holds a list of `ASCII` string. Separated by the symbol vertical bar `|`.

#### Example

Suppose you use the following configuration

| Variable | Description  | Type    | Default Value             |
| -------- | ------------ | ------- | ------------------------- |
| MyArgA   | true/false   | Boolean | true                      |
| MyArgB   | a float num  | Number  | 10.9                      |
| MyArgC   | a ASCII Str  | String  | Hello World!              |
| MyArgD   | a ASCII list | Select  | OptionA\|OptionB\|OptionC |

:::note
Only ASCII string is supported currently
:::

Then you're allowed to tweak these variables to be used in your strategy before trading. `MyArgD` will appear as a list consisting of `OptionA`, `OptionB` and `OptionC`.

![image](https://user-images.githubusercontent.com/5862369/56237500-b3511900-60be-11e9-878d-3e5c2cff4991.png)

#### ç¯„ä¾‹

ç•¶ä½¿ç”¨è€…è‡ªå®šç¾©åƒæ•¸ R1ï¼Œä½¿ç”¨ä»¥ä¸‹æ–¹æ³•å¯åœ¨ç¨‹å¼å…§å–å›æ‰€å®šç¾©çš„ R1 æ•¸å€¼
![image](https://drive.google.com/uc?export=view&id=16-bHa0jOZvPerOqEdIKRwDXlH50MHplr)

:::note
You can access these arguments by `self['argName']`
:::

```python
def trade(self, information):
    R1 = float(self['R1'])

CA.log(self['MyArgA']) # true
CA.log(str(self['MyArgA'].__class__)) # <class 'str'>

CA.log(self['MyArgB']) # 10.9
CA.log(str(self['MyArgB'].__class__)) # <class 'str'>

CA.log(self['MyArgC']) # Hello World!
CA.log(str(self['MyArgC'].__class__)) # <class 'str'>

CA.log(self['MyArgD']) # OptionC
CA.log(str(self['MyArgD'].__class__)) # <class 'str'>
```

:::caution All of the types are string in python

So if you want to check MyArgA is true or not, you have to use it like `if self['MyArgA'] == 'true'` instead of ~~`if self['MyArgA]`~~.

:::

## é»ƒé‡‘äº¤å‰ç­–ç•¥ç¯„ä¾‹

```python
class Strategy():
    # option setting needed
    def __setitem__(self, key, value):
        self.options[key] = value

    # option setting needed
    def __getitem__(self, key):
        return self.options.get(key, '')

    def __init__(self):
        # strategy property
        self.subscribed_books = {
            'Bitfinex': {
                'pairs': ['ETH-USDT'],
            },
        }
        self.period = 10 * 60
        self.options = {}

        # user defined class attribute
        self.last_type = 'sell'
        self.last_cross_status = None
        self.close_price_trace = np.array([])
        self.ma_long = 10
        self.ma_short = 5
        self.UP = 1
        self.DOWN = 2

    def on_order_state_change(self,  order):
        CA.log("on order state change message: " + str(order) + " order price: " + str(order["price"]))

    def get_current_ma_cross(self):
        s_ma = talib.SMA(self.close_price_trace, self.ma_short)[-1]
        l_ma = talib.SMA(self.close_price_trace, self.ma_long)[-1]
        if np.isnan(s_ma) or np.isnan(l_ma):
            return None
        if s_ma > l_ma:
            return self.UP
        return self.DOWN


    # called every self.period
    def trade(self, information):
        exchange = list(information['candles'])[0]
        pair = list(information['candles'][exchange])[0]
        target_currency = pair.split('-')[0]  #ETH
        base_currency = pair.split('-')[1]  #USDT
        base_currency_amount = self['assets'][exchange][base_currency]
        target_currency_amount = self['assets'][exchange][target_currency]
        # add latest price into trace
        close_price = information['candles'][exchange][pair][0]['close']
        self.close_price_trace = np.append(self.close_price_trace, [float(close_price)])
        # only keep max length of ma_long count elements
        self.close_price_trace = self.close_price_trace[-self.ma_long:]
        # calculate current ma cross status
        cur_cross = self.get_current_ma_cross()
        if cur_cross is None:
            return []
        if self.last_cross_status is None:
            self.last_cross_status = cur_cross
            return []
        # cross up
        if self.last_type == 'sell' and cur_cross == self.UP and self.last_cross_status == self.DOWN:
            CA.log('buying 1 unit of ' + str(target_currency))
            self.last_type = 'buy'
            self.last_cross_status = cur_cross
            return [
                {
                    'exchange': exchange,
                    'amount': 1,
                    'price': -1,
                    'type': 'MARKET',
                    'pair': pair,
                }
            ]
        # cross down
        elif self.last_type == 'buy' and cur_cross == self.DOWN and self.last_cross_status == self.UP:
            CA.log('assets before selling: ' + str(self['assets'][exchange][base_currency]))
            self.last_type = 'sell'
            self.last_cross_status = cur_cross
            return [
                {
                    'exchange': exchange,
                    'amount': -target_currency_amount,
                    'price': -1,
                    'type': 'MARKET',
                    'pair': pair,
                }
            ]
        self.last_cross_status = cur_cross
        return []

```

## Binary Code

ä½¿ç”¨ python é–‹ç™¼æ™‚ï¼Œå¯ä»¥é¸æ“‡ä¸Šå‚³ binary code ä¿è­·åŸå§‹ç¢¼
è«‹å‹™å¿…ä½¿ç”¨ python 3.6 ç‰ˆæœ¬é€²è¡Œç·¨è­¯

1. è«‹å…ˆä»¥ `python3 -m py_compile strategy.py` å°‡åŸå§‹ç¢¼ç·¨è­¯
2. è‡³ `./__pycache__ ` ä¸­æ‰¾åˆ° `strategy.cpython-36.pyc`
3. åˆ° My Strategy çš„ Edit Strategy é é¢é¸æ“‡ Use Binary Code å¾Œä¸Šå‚³ã€‚
